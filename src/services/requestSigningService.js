import crypto from 'crypto'\nimport { serverConfig } from '@/config/serverConfig'\n\nexport class RequestSigningService {\n  constructor() {\n    this.algorithm = 'sha256'\n    this.signatureHeader = 'X-Request-Signature'\n    this.timestampHeader = 'X-Request-Timestamp'\n    this.timestampTolerance = 300000 // 5 minutes\n  }\n\n  /**\n   * Generate a signature for a request\n   * @param {string} method - HTTP method\n   * @param {string} path - Request path\n   * @param {object} body - Request body\n   * @param {number} timestamp - Request timestamp\n   * @param {string} secret - Signing secret\n   * @returns {string} - Base64 encoded signature\n   */\n  generateSignature(method, path, body, timestamp, secret) {\n    // Create the string to sign\n    const bodyString = body ? JSON.stringify(body) : ''\n    const stringToSign = `${method.toUpperCase()}\\n${path}\\n${bodyString}\\n${timestamp}`\n    \n    // Generate HMAC signature\n    const hmac = crypto.createHmac(this.algorithm, secret)\n    hmac.update(stringToSign, 'utf8')\n    \n    return hmac.digest('base64')\n  }\n\n  /**\n   * Sign a request (client-side)\n   * @param {string} method - HTTP method\n   * @param {string} path - Request path\n   * @param {object} body - Request body\n   * @returns {object} - Headers to add to the request\n   */\n  signRequest(method, path, body = null) {\n    // Only available on server-side due to secret\n    if (typeof window !== 'undefined') {\n      console.warn('Request signing is only available on server-side')\n      return {}\n    }\n\n    const timestamp = Date.now()\n    const secret = serverConfig.api.internalKey || serverConfig.jwt.secret\n    \n    const signature = this.generateSignature(method, path, body, timestamp, secret)\n    \n    return {\n      [this.signatureHeader]: signature,\n      [this.timestampHeader]: timestamp.toString()\n    }\n  }\n\n  /**\n   * Verify a request signature (server-side)\n   * @param {object} req - Express request object\n   * @param {string} secret - Signing secret\n   * @returns {boolean} - Whether the signature is valid\n   */\n  verifySignature(req, secret) {\n    try {\n      const signature = req.headers[this.signatureHeader.toLowerCase()]\n      const timestamp = req.headers[this.timestampHeader.toLowerCase()]\n      \n      if (!signature || !timestamp) {\n        return false\n      }\n\n      // Check timestamp tolerance\n      const now = Date.now()\n      const requestTime = parseInt(timestamp)\n      \n      if (Math.abs(now - requestTime) > this.timestampTolerance) {\n        console.warn('Request timestamp outside tolerance window')\n        return false\n      }\n\n      // Generate expected signature\n      const method = req.method\n      const path = req.url || req.path\n      const body = req.body\n      \n      const expectedSignature = this.generateSignature(\n        method,\n        path,\n        body,\n        requestTime,\n        secret\n      )\n\n      // Compare signatures using timing-safe comparison\n      return crypto.timingSafeEqual(\n        Buffer.from(signature, 'base64'),\n        Buffer.from(expectedSignature, 'base64')\n      )\n      \n    } catch (error) {\n      console.error('Signature verification error:', error)\n      return false\n    }\n  }\n\n  /**\n   * Middleware for verifying request signatures\n   * @param {boolean} required - Whether signature is required\n   * @returns {function} - Express middleware function\n   */\n  middleware(required = false) {\n    return (req, res, next) => {\n      const secret = serverConfig.api.internalKey || serverConfig.jwt.secret\n      \n      // Check if signature headers are present\n      const hasSignature = req.headers[this.signatureHeader.toLowerCase()] &&\n                          req.headers[this.timestampHeader.toLowerCase()]\n      \n      if (!hasSignature) {\n        if (required) {\n          return res.status(401).json({\n            success: false,\n            message: 'Request signature required'\n          })\n        }\n        // If not required, continue without verification\n        return next()\n      }\n\n      // Verify the signature\n      if (!this.verifySignature(req, secret)) {\n        return res.status(401).json({\n          success: false,\n          message: 'Invalid request signature'\n        })\n      }\n\n      // Signature valid, continue\n      next()\n    }\n  }\n\n  /**\n   * Create signed axios instance for server-to-server communication\n   * @param {string} baseURL - Base URL for requests\n   * @returns {object} - Configured axios instance\n   */\n  createSignedAxiosInstance(baseURL) {\n    const axios = require('axios')\n    \n    const instance = axios.create({\n      baseURL,\n      timeout: 30000,\n      headers: {\n        'Content-Type': 'application/json',\n        'User-Agent': 'BetJockey-Admin/1.0'\n      }\n    })\n\n    // Request interceptor to add signatures\n    instance.interceptors.request.use((config) => {\n      const signatureHeaders = this.signRequest(\n        config.method.toUpperCase(),\n        config.url,\n        config.data\n      )\n      \n      config.headers = {\n        ...config.headers,\n        ...signatureHeaders\n      }\n      \n      return config\n    })\n\n    return instance\n  }\n\n  /**\n   * Generate a nonce for additional security\n   * @returns {string} - Random nonce\n   */\n  generateNonce() {\n    return crypto.randomBytes(16).toString('hex')\n  }\n\n  /**\n   * Create a webhook signature (for external services)\n   * @param {string} payload - Webhook payload\n   * @param {string} secret - Webhook secret\n   * @returns {string} - Signature\n   */\n  createWebhookSignature(payload, secret) {\n    const hmac = crypto.createHmac('sha256', secret)\n    hmac.update(payload, 'utf8')\n    return `sha256=${hmac.digest('hex')}`\n  }\n\n  /**\n   * Verify a webhook signature\n   * @param {string} payload - Webhook payload\n   * @param {string} signature - Received signature\n   * @param {string} secret - Webhook secret\n   * @returns {boolean} - Whether signature is valid\n   */\n  verifyWebhookSignature(payload, signature, secret) {\n    const expectedSignature = this.createWebhookSignature(payload, secret)\n    \n    try {\n      return crypto.timingSafeEqual(\n        Buffer.from(signature),\n        Buffer.from(expectedSignature)\n      )\n    } catch {\n      return false\n    }\n  }\n}\n\nexport default new RequestSigningService()